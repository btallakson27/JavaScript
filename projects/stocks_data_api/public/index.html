<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Data Web Scraper</title>
    <!--7. Do a bit of styling-->
    <style>
        body { padding: 20px; font-family: sans-serif; background: rgb(163, 187, 163); }
        header { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
        main {display: flex; justify-content: center;}
        input { flex: 0.1; padding: 8px; border-radius: 6px; border: 1px solid black; }
        button { padding: 8px 12px; border-radius: 6px; cursor: pointer; }
        table { width: 30%; border-collapse: collapse; margin-top: 20px; background: white; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background: #f0f0f0; }
    </style>
</head>
<body>
   <!--6. Now that your backend works, you design what the user sees. You Start with this.-->
    <header>
        <input id="ticker" placeholder="Enter stock ticker..."/> <!--why do we need an ID if it's the only input bar? You don't, but it's
        just a good habit to develop for clearer DOM access, it prevents it from breaking if you end up adding another input later-->
        <button id="searchBtn">Search</button>
    </header>
    <main></main>
    <script>
        // 8. Here you start to make the data visible to the user. Now you make the frontend interactive. Grab DOM elements.
        // Document Object Model. When your browser loads an HTML page, it doesn’t just display the text — it builds a structured tree 
        // in memory that represents every part of that page. That tree is called the DOM. A DOM element is an object that JavaScript can accees and modify.
        const tickerInput=document.getElementById('ticker')
        const searchBtn=document.querySelector('searchBtn')
        const mainContainer=document.querySelector('main')

        // 9. Create the main function. This is where the frontend will, get the user's input, send it to the backend, display the returned data.
        async function fetchStockData(){
                // you don't want these lines in your try-catch block because you validate user input before making any network call.
                // If it’s empty, you stop execution early (return). The try block only runs if you actually have a ticker worth fetching.
                // That’s exactly how you want it — it avoids wasting time making a useless API call.
                // very first thing you want to check before sending stock_ticker to backend is make sure there are no extra blank spaces
            const stock_ticker=tickerInput.value.trim() // .trim() is a string method that remoes any extra spaces from the beginning and end of a string.

            // If user did not enter a stock ticker, show message and stop
            if (!stock_ticker) {
                mainContainer.innerText = 'Please enter a stock ticker.' // you could use innerHTML but innerTExt is safer when you're just inserting plain text.
            // inner HTML would interpret tages and could cause issues if user input accidentally contains HTML.
                return
            }
            // you can make the try-catch whenever you want, just don't forget!
            try{
                console.log("Sending request with:", { stock_ticker })
                // 10. Make the API call (frontend → backend). This line connects the frontend to your backend route from earlier.
            // When the user clicks “Search,” this sends their ticker to /api, and waits for the backend’s response.
            // You now have full client-server communication.
            const res=await fetch('/api',{ // here you are sending a network call (an API call). fetch always goes in a try/catch block.
                method: 'POST',
                headers: {'Content-Type': 'application/json'}, // application must be singular
                body: JSON.stringify({stock_ticker})
            })
            console.log("Response received:", res)

            if (!res.ok){ // literally means “the response is not OK.”
                throw new Error(`Server responded with status ${res.status}`) // this line is a manual error check after making a fetch request.
                // “If the server didn’t respond with a success code (200–299), treat it as an error and stop here.”
            }

            // 11. Once you get the response, parse JSON response, and extract prices array safely.
            console.log("About to parse JSON")
            const data=await res.json() // turns the backend’s JSON response (e.g. {"prices":[...]}) into a JavaScript object so you can work with it in JS.
            console.log("Parsed JSON:", data)
                
            const prices = Array.isArray(data?.prices) ? data.prices : []; 
                // the backend sends back this JSON. res.status(200).send({ prices: prices || [] })
                // and you created the variable data above that contains this JSON info. So you are now checking if prices is actually in there.
                console.log("Prices array length:", prices.length);

            // 12. Now you have useable data that's waiting to be processed for the user. 
            // Before adding new data, you wipe out any previous table or messages, to ensure you only see the latest search result.
            mainContainer.innerHTML=''

            // 13. If there are no prices (meaning no data came back for that stock ticker), show a message on the page and stop running the rest of the code. Much better than showing an empty table.
            // It’s not checking whether the user didn’t enter a ticker — it’s checking whether no data was returned for that ticker.
            // check if data was returned for the ticker input by user. can I move this above const res=await fetch('/api') above?
            // No, you can’t move that above the fetch call. You don;t know whether there's data (prices) until AFTER you call the backend and get the response.
            if (!prices.length){ 
                mainContainer.innerText='No data found for this ticker'
                return
            }
            
            // filter prices to make sure only clean, valid data goes in the table. but why wouldn't they? what else could happen?
            // possible issues include, Backend or API returned null or missing fields. Some entries have empty dates or prices due to a scrape error.
            // JSON got partially corrupted. Different tickers might have different data formats. 
            // So filtering ensures your frontend doesn’t crash or show blank rows if a backend entry looks like: { date: "", close: null }
            //the bottom line, always filer entries when scraping data to prevent issues.
            const filteredPrices=prices.filter(entry => entry.date && entry.close != null) 
        
            // 15. Now we have the data ready to go, so we must create a table element. You’re building from the inside out!!! 
            // The reason you create the <table> dynamically in JavaScript instead of writing it directly in HTML is
            // because the data (and number of rows) depends on what the user searches for. A static table in HTML can’t easily adjust to user input.
            const table=document.createElement('table') 
        
            // 16. Build the header row.
            const thead=document.createElement('thead')  // this is a container (a section) that holds header rows, not data rows. think of it like: <thead> ...header rows go here... </thead>
            const headerRow=document.createElement('tr') // this is the single row that contains your column labels — “Date” and “Close Price”.
            // So when you append headerRow to thead, you’re essentially saying: “Put this row of column names inside the header section of my table.”
            // thead, th, tr, and td are core built-in HTML elements taht always exist in every browser. you can't just name them whatever you want.

            // 17. put the text in the top row of the table (headerRow)
            ['Date', 'Close Price'].forEach(text=>{ // loop over every string in the array... 
                const th=document.createElement('th') // and for every string create a <th> element, not visible until appendid.
                th.innerText=text // this is the single row that contains your column labels — “Date” and “Close Price”.
                headerRow.appendChild(th) // set the visible text inside the <th> // why doesn't th need quotes? because it's a variable, not a string. when you put it in quotes the first time, it becomes a variable.
            })

            // 18. Then you attach it all together here. 
            thead.appendChild(headerRow) // “take the thead containter and attach the first row that contains the text 'Date' and 'Close Price'. 
            table.appendChild(thead) // “take the table element and attach the thead container to it. 

            // 19. At this point we have created the table header, which just sets up the column names. That part does not add the actual data.
            const tbody=document.createElement('tbody') //Now this next part is creating the body of the table, where the actual rows of data 
            // will live. tbody is separate from thead, and HTML tables are usually structured as:
                // <table>
                //   <thead>...</thead>
                //   <tbody>...</tbody>
                // </table>
            // Without a tbody, your table won’t have rows of actual data — just the header.
                console.log(data)
            filteredPrices.forEach(entry => { // filteredPrices contains all vaild data.
                const row=document.createElement('tr') // → creates a new table row

                const dateCell=document.createElement('td') // → creates an empty cell element in memory for the date.
                dateCell.innerText=entry.date // → puts the actual date string inside the cell. you made a variable named dateCell not td, since td isn't defined anywhere. you never did td.innerText=entry.date
                row.appendChild(dateCell) // → adds the date cell to the row.

                const closeCell = document.createElement('td') //→ creates a cell for the closing price. why is this also td? Because <td> stands for table data cell, and every table row (<tr>) contains one or more <td> cells.
                    closeCell.innerText = `$${entry.close.toFixed(2)}` // → fills the price nicely formatted to show only 2 decimal places.
                    row.appendChild(closeCell) // → adds the close price cell to the row.
                    tbody.appendChild(row) // → adds the completed row to the table body.
            })

            // 20. Attach everything to the DOM. Once the table is fully built, it’s inserted into the <main> area of your HTML.
            // This will finally show the table in the browser. 
            table.appendChild(tbody)
            mainContainer.appendChild(table)
            }catch(err){ // Handle fetch or parsing errors gracefully
                console.error('Error fetching stock data:', err.message) //there is a problem happening here!
                mainContainer.innerText='Error fetching stock data. Please try again'
            }     
        }
        // Add event listener: run fetchStockData() when button is clicked
        sendBtn.addEventListener('click', fetchStockData)
    </script>
</body>
</html>

