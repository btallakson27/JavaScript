<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Data Web Scraper</title>
    <!--7. Do a bit of styling-->
    <style>
        body { padding: 20px; font-family: sans-serif; background: rgb(163, 187, 163); }
        header { display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; }
        main {display: flex; justify-content: center;}
        input { flex: 0.1; padding: 8px; border-radius: 6px; border: 1px solid black; }
        button { padding: 8px 12px; border-radius: 6px; cursor: pointer; }
        table { width: 30%; border-collapse: collapse; margin-top: 20px; background: white; }
        th, td { border: 1px solid #ccc; padding: 8px; text-align: left; }
        th { background: #f0f0f0; }
    </style>
</head>
<body>
   <!--6. Now that your backend works, you design what the user sees. You Start with this.-->
    <header>
        <input id="ticker" placeholder="Enter stock ticker..."/> <!--why do we need an ID if it's the only input bar? You don't, but it's
        just a good habit to develop for clearer DOM access, it prevents it from breaking if you end up adding another input later-->
        <button id="searchBtn">Search</button>
    </header>
    <main></main>
    <script>
        // 8. Here you start to make the data visible to the user. Now you make the frontend interactive. Grab DOM elements.
        // Document Object Model. When your browser loads an HTML page, it doesn’t just display the text — it builds a structured tree 
        // in memory that represents every part of that page. That tree is called the DOM. A DOM element is an object that JavaScript can accees and modify.
        const tickerInput=document.getElementById('ticker')
        const searchBtn=document.querySelector('searchBtn')
        const mainContainer=document.querySelector('main')

        // 9. Create the main function. This is where the frontend will, get the user's input, send it to the backend, display the returned data.
        async function fetchStockData(){
                // you don't want these lines in your try-catch block because you validate user input before making any network call.
                // If it’s empty, you stop execution early (return). The try block only runs if you actually have a ticker worth fetching.
                // That’s exactly how you want it — it avoids wasting time making a useless API call.
                // very first thing you want to check before sending stock_ticker to backend is make sure there are no extra blank spaces
            const stock_ticker=tickerInput.value.trim() // .trim() is a string method that remoes any extra spaces from the beginning and end of a string.

            // If user did not enter a stock ticker, show message and stop
            if (!stock_ticker) {
                mainContainer.innerText = 'Please enter a stock ticker.'
                return
            }
            // you can make the try-catch whenever you want, just don't forget!
            try{
                console.log("Sending request with:", { stock_ticker })
                // 10. Make the API call (frontend → backend). This line connects the frontend to your backend route from earlier.
            // When the user clicks “Search,” this sends their ticker to /api, and waits for the backend’s response.
            // You now have full client-server communication.
            const res=await fetch('/api',{ // here you are sending a network call (an API call). fetch always goes in a try/catch block.
                method: 'POST',
                headers: {'Content-Type': 'application/json'}, // application must be singular
                body: JSON.stringify({stock_ticker})
            })
            console.log("Response received:", res)

            if (!res.ok){ // literally means “the response is not OK.”
                throw new Error(`Server responded with status ${res.status}`) // this line is a manual error check after making a fetch request.
                // “If the server didn’t respond with a success code (200–299), treat it as an error and stop here.”
            }

            // 11. Once you get the response, parse JSON response, and extract prices array safely.
            console.log("About to parse JSON")
            const data=await res.json() // turns the backend’s JSON response (e.g. {"prices":[...]}) into a JavaScript object so you can work with it in JS.
            console.log("Parsed JSON:", data)
                
            const prices = Array.isArray(data?.prices) ? data.prices : []; 
                // what you have is the wanted data which we called 'prices' on the backend, so let's call it the same thing here. not the 
                // same as prices on the backend.
                // This line creates a constant prices that safely checks whether data.prices exists and is an array. If it is, it assigns 
                // that array to prices; otherwise, it assigns an empty array.
                console.log("Prices array length:", prices.length);

            // 12. Now you have useable data that's waiting to be processed for the user. 
            // Before adding new data, you wipe out any previous table or messages, to ensure you only see the latest search result.
            mainContainer.innerHTML=''

            // 13. If there are no prices (meaning no data came back for that stock ticker), show a message on the page and stop running the rest of the code. Much better than showing an empty table.
            // It’s not checking whether the user didn’t enter a ticker — it’s checking whether no data was returned for that ticker.
            if (!prices.length){ 
                mainContainer.innerText='No data found for this ticker'
                return
            }
            
            // 14. Filter out bad entries. Removes any malformed or incomplete rows before display.
            // != null means, "is not null or undefined.", so only clean, valid data goes to the table.
            // so this line says, “Go through every stock price in prices, and only keep the ones that have both a date and a valid closing price.”
            console.log("Building table, data looks like:", prices.slice(0, 3))
            const filteredPrices=prices.filter(entry => entry.date && entry.close != null) 
        
            // 15. Now we have the data ready to go, so we must create a table element. You’re building from the inside out!!! 
            // The reason you create the <table> dynamically in JavaScript instead of writing it directly in HTML is
            // because the data (and number of rows) depends on what the user searches for. A static table in HTML can’t easily adjust to user input.
            const table=document.createElement('table') 
        
            // 16. Build the header row.
            const thead=document.createElement('thead')  // this is a contaiener (a section) that hp;ds header rows, not data rows. think of it like: <thead> ...header rows go here... </thead>
            const headerRow=document.createElement('tr') // this is the single row that contains your column labels — “Date” and “Close Price”.
            // So when you append headerRow to thead, you’re essentially saying: “Put this row of column names inside the header section of my table.”

            // 17. Creates a header with two columns: “Date” and “Close Price.”
            // …but notice: this only creates the header, it does not create any rows for actual data. That’s why we need the tbody and the 
            // forEach loop over filteredPrices below — to actually populate the table with the real values under the headers.Think of it as:
                // thead → column labels
                // tbody → the real data rows. It’s totally normal to need both.
            ['Date', 'Close Price'].forEach(text=>{ // ['Date', 'Close Price'] creates a small array with two strings, and then calls .forEach(...) to loop through each item in that array. So the loop runs twice: First time → text = 'Date' Second time → text = 'Close Price'
                const th=document.createElement('th') // creates a new <th> element — a blank table header cell.
                th.innerText=text // puts text inside that header cell, date on first loop, close price on second.
                headerRow.appendChild(th) // Takes the newly created <th> cell and adds it to your header row (<tr>).
            })

            // 18. Then you attach it all together here. 
            thead.appendChild(headerRow) // “Attach the header row to the table’s header section.”
            table.appendChild(thead) // “Attach the table header section to the full table.”

            // 19. At this point we have created the table header, which just sets up the column names. That part does not add the actual data.
            const tbody=document.createElement('tbody') //Now this next part is creating the body of the table, where the actual rows of data 
            // will live. tbody is separate from thead, and HTML tables are usually structured as:
                // <table>
                //   <thead>...</thead>
                //   <tbody>...</tbody>
                // </table>
            // Without a tbody, your table won’t have rows of actual data — just the header.
                console.log(data)
            filteredPrices.forEach(entry => { // filteredPrices contains all vaild data.
                const row=document.createElement('tr') // → creates a new table row

                const dateCell=document.createElement('td') // → creates an empty cell element in memory for the date.
                dateCell.innerText=entry.date // → puts the actual date string inside the cell.
                row.appendChild(dateCell) // → adds the date cell to the row.

                const closeCell = document.createElement('td') //→ creates a cell for the closing price.
                    closeCell.innerText = `$${entry.close.toFixed(2)}` // → fills the price nicely formatted.
                    row.appendChild(closeCell) // → adds the close price cell to the row.
                    tbody.appendChild(row) // → adds the completed row to the table body.
            })

            // 20. Attach everything to the DOM. Once the table is fully built, it’s inserted into the <main> area of your HTML.
            // This will finally show the table in the browser. 
            table.appendChild(tbody)
            mainContainer.appendChild(table)
            }catch(err){ // Handle fetch or parsing errors gracefully
                console.error('Error fetching stock data:', err.message) //there is a problem happening here!
                mainContainer.innerText='Error fetching stock data. Please try again'
            }     
        }
        // Add event listener: run fetchStockData() when button is clicked
        sendBtn.addEventListener('click', fetchStockData)
    </script>
</body>
</html>

